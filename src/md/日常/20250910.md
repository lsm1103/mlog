## 机会
- 海外电商大数据分析平台
    - https://www.kalodata.com/explore
    - 提供海外电商数据分析服务，帮助企业了解海外市场动态，优化业务决策。

## 技术
- claude code的三方开源项目
    - 🌊 Claude 领先的代理编排平台。部署智能多代理群，协调自主工作流程，构建对话式 AI 系统。具有企业级架构、分布式群体智能、RAG 集成以及通过 MCP 协议的原生 Claude Code 支持
    - https://github.com/ruvnet/claude-flow
    🌟 感觉没什么用
- Claude Code 逆向工程研究仓库
    - 该仓库是对 Claude Code v1.0.33 进行深度逆向工程分析的完整研究资料库。通过对混淆源代码的系统性分析，我们揭示了这个现代AI编程助手的核心架构设计、实现机制和运行逻辑。
    - https://github.com/shareAI-lab/analysis_claude_code
- livekit：go写的webrtc+ai agent项目
    - https://github.com/livekit
    - 里面有很多音视频的相关项目，有单纯webrtc的音视频通话+文本聊天；有音视频agent的，还有游戏的；感觉能做很多东西。
### llm相关的项目
设计一套提示词，让llm在对话过程中输出工具调用（包含mcp的东西）。有趣的时这里有一个 "draw" 的工具，
这个工具是一个mcp，它也是通过提示词让llm生成一个html代码，这个代码执行出来的效果是可以生成单纯静态图片，
也可以生成可以交互的教学网页，这个创意感觉可以用在很多地方。

> 这是 "draw" 提示词代码
```python
def get_interactive_demo_prompt(self, description: str, problem: str = "", assess_points: str = "", conversation: str = "") -> str:
    """获取互动演示代码生成的提示模板"""
    prompt = f"""
你是一个专精于数学和科学教育可视化的前端开发 AI。

你的任务是根据教师提供的 **题目内容、考核点，以及师生对话记录**，生成一段 **可在浏览器中运行的 HTML+CSS+JavaScript 交互演示代码**，用于帮助学生理解和掌握当前教学中的关键考核点。

请注意：题目仅作为上下文参考，生成内容应聚焦“当前对话所提及的考核点”，不要展示题目完整流程，也不要提供解题结果。
代码生成应围绕考核点进行，而不是泛泛根据题目；师生对话作为辅助理解考核点，而不是用来“还原题目或解题过程”。

---

## ✏️ 教学目标：

- 根据“考核点”确定展示的重点概念、变量和交互逻辑。
- 根据“对话记录”理解教师目前想补充的演示内容或交互形式。
- 生成代码应紧扣当前对话中提及的考核点，围绕其进行可视化设计。

---

## 📥 输入内容：

### 题目：
{problem}

### 考核点：
{assess_points}

### 当前对话记录：
{conversation}

### 当前描述：
{description}

---

## 🛠️ 输出要求：

1. 使用 HTML+CSS+JavaScript 编写完整、可运行的交互式页面。
2. 所有演示必须围绕“当前对话中涉及的考核点”展开，而不是完整复现题目或题解流程。
3. **不要输出题目的答案或解题过程**，演示内容仅用于帮助理解关键概念和变量之间的关系。
4. 出于兼容性和渲染性能考虑，**请尽量避免使用 LaTeX 或 MathJax 渲染公式**，优先使用普通 HTML 元素展示数学内容。
5. 鼠标悬浮、点击或滑块控制应体现关键概念的动态过程。
6. 页面需包含适当的数学元素标注，如变量符号、表达式、函数图、角度、几何图形、数轴等。
7. 鼓励使用原生 JS 或轻量库（如 p5.js、Plotly.js、Chart.js、Desmos API），避免引入冗余依赖。
8. 输出必须是**完整 HTML 文件内容**，包括：
- `<!DOCTYPE html>` 开头
- `<script>` 中包含完整交互逻辑
- `<style>` 中包含样式
9. **不要解释代码或添加注释**，只输出纯 HTML 代码。

---

## 🎯 示例教学目标参考（用于启发，但非输出内容）：

- 函数图像的动态变化与滑块值联动，帮助学生理解函数图的形状变化
- 通过交互演示“平移”、“对称”、“旋转”等几何变换
- 动态反馈学生输入的代数解与图像上的解之间的对应关系
- 控制变量观察结果变化，培养数学建模思维

---

现在请基于上方输入内容生成 HTML 演示代码
"""
    return prompt
```

> 这是 "draw" 工具的效果

```html-render
<button onclick="alert('Hello!')">点击我</button>
```

<button onclick="alert('Hello!')">点击我</button>

<style>
    .demo-container {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        padding: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        max-width: 800px; /* 可控制整体宽度 */
        width: 100%;
        margin: 20px auto;
        transform: scale(0.8); /* 可控制整体缩放 */
        transform-origin: center top;
    }
    .demo-title {
        text-align: center;
        margin-bottom: 30px;
        font-size: 2.2rem;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }
    .controls {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-bottom: 30px;
        gap: 15px;
    }
    .slider-container {
        width: 100%;
        max-width: 500px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
    }
    .slider-label {
        display: flex;
        justify-content: space-between;
        width: 100%;
        font-size: 1.1rem;
    }
    input[type="range"] {
        width: 100%;
        height: 8px;
        border-radius: 4px;
        background: #ddd;
        outline: none;
        -webkit-appearance: none;
    }
    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #ff6b6b;
        cursor: pointer;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
    }
    .equations {
        display: flex;
        justify-content: center;
        gap: 40px;
        margin-bottom: 30px;
        flex-wrap: wrap;
    }
    .equation-box {
        background: rgba(255, 255, 255, 0.2);
        padding: 15px 25px;
        border-radius: 12px;
        text-align: center;
        min-width: 200px;
        transition: all 0.3s ease;
    }
    .equation-box.original {
        border: 2px solid #4ecdc4;
    }
    .equation-box.translated {
        border: 2px solid #ff6b6b;
    }
    .equation {
        font-size: 1.5rem;
        font-weight: bold;
        margin-bottom: 5px;
    }
    .description {
        font-size: 0.9rem;
        opacity: 0.9;
    }
    canvas {
        background: white;
        border-radius: 12px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        display: block;
        margin: 0 auto;
    }
    .info-box {
        margin-top: 20px;
        padding: 15px;
        background: rgba(255, 255, 255, 0.15);
        border-radius: 12px;
        text-align: center;
        font-size: 1.1rem;
    }
</style>

<div class="demo-container">
    <h1 class="demo-title">抛物线垂直平移演示</h1>
    
    <div class="controls">
        <div class="slider-container">
            <div class="slider-label">
                <span>向下平移量: <span id="shift-value">0</span> 单位</span>
                <span>目标: 3 单位</span>
            </div>
            <input type="range" id="shift-slider" min="0" max="3" step="0.1" value="0">
        </div>
    </div>
    
    <div class="equations">
        <div class="equation-box original">
            <div class="equation">y = x²</div>
            <div class="description">原始抛物线</div>
        </div>
        <div class="equation-box translated">
            <div class="equation">y = x² - <span id="current-shift">0</span></div>
            <div class="description">平移后抛物线</div>
        </div>
    </div>
    
    <div style="position: relative; margin: 30px auto; width: 600px; height: 400px;">
        <canvas id="graph" width="600" height="400"></canvas>
    </div>
    
    <div class="info-box">
        拖动滑块观察抛物线 y = x² 向下平移的过程
    </div>
</div>

<script>
    // 延迟执行，避免与Svelte组件冲突
    setTimeout(function() {
        const canvas = document.getElementById('graph');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        const slider = document.getElementById('shift-slider');
        const shiftValue = document.getElementById('shift-value');
        const currentShift = document.getElementById('current-shift');
        
        if (!ctx || !slider || !shiftValue || !currentShift) return;
        
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height / 2;
        const scale = 30;
        
        function drawAxis() {
            ctx.clearRect(0, 0, width, height);
            
            // 绘制坐标轴
            ctx.beginPath();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            
            // X轴
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            
            // Y轴
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, height);
            
            ctx.stroke();
            
            // 绘制刻度
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 1;
            ctx.font = '12px Arial';
            ctx.fillStyle = '#333';
            
            // X轴刻度
            for (let i = -10; i <= 10; i++) {
                const x = centerX + i * scale;
                if (x >= 0 && x <= width) {
                    ctx.beginPath();
                    ctx.moveTo(x, centerY - 5);
                    ctx.lineTo(x, centerY + 5);
                    ctx.stroke();
                    
                    if (i !== 0) {
                        ctx.fillText(i.toString(), x - 5, centerY + 20);
                    }
                }
            }
            
            // Y轴刻度
            for (let i = -8; i <= 8; i++) {
                const y = centerY - i * scale;
                if (y >= 0 && y <= height) {
                    ctx.beginPath();
                    ctx.moveTo(centerX - 5, y);
                    ctx.lineTo(centerX + 5, y);
                    ctx.stroke();
                    
                    if (i !== 0) {
                        ctx.fillText(i.toString(), centerX + 10, y + 5);
                    }
                }
            }
        }
        
        function drawParabola(shift, color, lineWidth = 2) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            
            let firstPoint = true;
            
            for (let x = -10; x <= 10; x += 0.1) {
                const y = x * x - shift;
                const screenX = centerX + x * scale;
                const screenY = centerY - y * scale;
                
                if (screenY >= 0 && screenY <= height && screenX >= 0 && screenX <= width) {
                    if (firstPoint) {
                        ctx.moveTo(screenX, screenY);
                        firstPoint = false;
                    } else {
                        ctx.lineTo(screenX, screenY);
                    }
                }
            }
            
            ctx.stroke();
        }
        
        function updateGraph() {
            const shift = parseFloat(slider.value);
            shiftValue.textContent = shift.toFixed(1);
            currentShift.textContent = shift.toFixed(1);
            
            drawAxis();
            
            // 绘制原始抛物线 (半透明)
            ctx.globalAlpha = 0.5;
            drawParabola(0, '#4ecdc4', 2);
            ctx.globalAlpha = 1.0;
            
            // 绘制平移后的抛物线
            drawParabola(shift, '#ff6b6b', 3);
            
            // 标记顶点
            ctx.fillStyle = '#ff6b6b';
            ctx.beginPath();
            ctx.arc(centerX, centerY + shift * scale, 5, 0, 2 * Math.PI);
            ctx.fill();
            
            // 标记原始顶点
            ctx.fillStyle = '#4ecdc4';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 5, 0, 2 * Math.PI);
            ctx.fill();
        }
        
        slider.addEventListener('input', updateGraph);
        
        // 初始化
        drawAxis();
        updateGraph();
    }, 500);
</script>